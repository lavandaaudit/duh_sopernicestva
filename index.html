<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IBONARIUM ‚Äî –ñ–∏–≤–∞ –ü–∞–≤—É—Ç–∏–Ω–∞</title>
    <style>
        body {
            margin: 0;
            background: radial-gradient(ellipse at center, #0a0015 0%, #000002 68%, #000 100%);
            color: #d0c8ff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            mix-blend-mode: screen;
        }
        #ui {
            position: absolute;
            top: 14px;
            left: 16px;
            pointer-events: none;
            font-size: 0.82em;
            line-height: 1.38;
            text-shadow: 0 0 9px #1a0033, 0 0 18px #330066;
            letter-spacing: 0.3px;
            opacity: 0.92;
            user-select: none;
        }
        #ui h1 {
            margin: 0 0 6px 0;
            font-size: 1.24em;
            background: linear-gradient(90deg, #a78dff, #ff78d2, #ff4eb8);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 1px;
        }
        .civ-a { color: #9d8aff; text-shadow: 0 0 10px #9d8aff; }
        .civ-b { color: #ff5ab5; text-shadow: 0 0 12px #ff5ab5; }
        .stats, .space-info {
            margin-top: 4px;
            opacity: 0.9;
        }
        .space-info div, .stats div {
            margin: 2px 0;
        }
        .label {
            opacity: 0.75;
            font-size: 0.92em;
        }
        .launch-info {
            margin-top: 8px;
            font-size: 0.74em;
            opacity: 0.70;
            line-height: 1.4;
        }
        .timer {
            font-family: monospace;
            letter-spacing: 0.8px;
            color: #c0b0ff;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <div id="ui">
        <h1>üåå IBONARIUM</h1>
       
        <div class="space-info">
            <div><span class="label">Kp:</span> <span id="kp">2.3</span></div>
            <div><span class="label">Flares:</span> <span id="flare">None</span></div>
            <div><span class="label">Protons ‚â•10 MeV:</span> <span id="proton">low</span></div>
            <div><span class="label">Solar Wind:</span> <span id="wind">380</span> km/s</div>
            <div><span class="label">Bz:</span> <span id="bz">+1.2</span> nT</div>
            <div><span class="label">Dst:</span> <span id="dst">-18</span> nT</div>
        </div>
        <div class="stats">
            <span class="civ-a">Order</span> <span id="pct-a">0.0%</span> ‚ÄÉ|
            <span class="civ-b">Flux</span> <span id="pct-b">0.0%</span><br>
            –ê–∫—Ç–∏–≤–Ω–∏—Ö –∑–≤‚Äô—è–∑–∫—ñ–≤: <span id="edges">0</span>
            <div class="launch-info">
                –ó–∞–ø—É—â–µ–Ω–æ: <span id="launch-date">—Å—å–æ–≥–æ–¥–Ω—ñ –æ 00:00</span><br>
                –ß–∞—Å —Ä–æ–±–æ—Ç–∏: <span id="timer" class="timer">0 –¥–Ω—ñ–≤ 00:00:00</span>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        let w, h;
        function resize() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        const launchDate = new Date();
        launchDate.setHours(0, 0, 0, 0);
       
        const options = { day: 'numeric', month: 'long', year: 'numeric' };
        document.getElementById('launch-date').textContent =
            launchDate.toLocaleDateString('uk-UA', options) + ' –æ 00:00';

        function updateTimer() {
            const now = new Date();
            const diffMs = now - launchDate;
            const diffSec = Math.floor(diffMs / 1000);
            const days = Math.floor(diffSec / 86400);
            const hours = Math.floor((diffSec % 86400) / 3600);
            const minutes = Math.floor((diffSec % 3600) / 60);
            const seconds = diffSec % 60;
            document.getElementById('timer').textContent =
                `${days} –¥–Ω—ñ–≤ ${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
        }
        setInterval(updateTimer, 1000);
        updateTimer();

        const NODES = 520;
        const MAX_DIST = 168;
        const nodes = [];
        const edges = [];

        class Node {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.owner = null;
                this.strength = 1.0;
                this.phase = Math.random() * Math.PI * 2;
                this.breath = 0;
                this.corruption = 0;
            }
        }

        for (let i = 0; i < NODES; i++) {
            let x = Math.random() * w * 1.7 - w * 0.35;
            let y = Math.random() * h * 1.7 - h * 0.35;
            nodes.push(new Node(x, y));
        }

        for (let i = 0; i < NODES; i++) {
            for (let j = i + 1; j < NODES; j++) {
                const d = Math.hypot(nodes[i].x - nodes[j].x, nodes[i].y - nodes[j].y);
                if (d < MAX_DIST) {
                    edges.push({
                        a: i,
                        b: j,
                        baseAlpha: 0.07 + (1 - d / MAX_DIST) * 0.38,
                        length: d
                    });
                }
            }
        }

        const centerA = { x: w * 0.28, y: h * 0.54 };
        const centerB = { x: w * 0.72, y: h * 0.46 };
        let startA = 0, distA = Infinity;
        let startB = 0, distB = Infinity;
        nodes.forEach((n, i) => {
            const da = Math.hypot(n.x - centerA.x, n.y - centerA.y);
            const db = Math.hypot(n.x - centerB.x, n.y - centerB.y);
            if (da < distA) { distA = da; startA = i; }
            if (db < distB) { distB = db; startB = i; }
        });
        nodes[startA].owner = 'A';
        nodes[startB].owner = 'B';

        let space = {
            kp: 2.3,
            flare: 'None',
            proton: 8,
            wind: 380,
            bz: 1.2,
            dst: -18
        };

        async function updateSpace() {
            try {
                const kpRes = await fetch('https://services.swpc.noaa.gov/products/noaa-planetary-k-index.json');
                const kpData = await kpRes.json();
                space.kp = parseFloat(kpData[kpData.length-1][1]) || space.kp;

                const flareRes = await fetch('https://services.swpc.noaa.gov/json/goes/primary/xray-flares-latest.json');
                const flares = await flareRes.json();
                const last = flares[flares.length-1] || {};
                const cls = last.current_class || last.max_class || 'None';
                space.flare = (cls.startsWith('M') || cls.startsWith('X')) ? cls[0] : 'None';

                const protonRes = await fetch('https://services.swpc.noaa.gov/json/goes/primary/integral-protons-1-day.json');
                const protons = await protonRes.json();
                const p = protons.filter(p => p.energy === '>=10 MeV').pop();
                space.proton = p ? p.flux : space.proton;

                const windRes = await fetch('https://services.swpc.noaa.gov/products/solar-wind/plasma-1-minute.json');
                const wind = await windRes.json();
                const lastWind = wind[wind.length-1] || {};
                space.wind = parseFloat(lastWind[2]) || space.wind;
                space.bz = parseFloat(lastWind[3]) || space.bz;

                space.dst = space.kp > 5 ? -50 - space.kp*12 : -10 - space.kp*4;

                document.getElementById('kp').textContent = space.kp.toFixed(1);
                document.getElementById('flare').textContent = space.flare;
                document.getElementById('proton').textContent = space.proton > 100 ? 'extreme' : space.proton > 30 ? 'high' : space.proton > 10 ? 'elevated' : 'low';
                document.getElementById('wind').textContent = Math.round(space.wind);
                document.getElementById('bz').textContent = space.bz.toFixed(1);
                document.getElementById('dst').textContent = Math.round(space.dst);
            } catch(e) {
                console.warn("Space weather fetch error", e);
            }
        }

        function simulate() {
            const now = Date.now();
            nodes.forEach(n => {
                n.breath = Math.sin(now * 0.00028 + n.phase) * 0.5 + 0.5;   // –ø–æ–≤—ñ–ª—å–Ω—ñ—à–µ –¥–∏—Ö–∞–Ω–Ω—è
            });

            nodes.forEach((n, i) => {
                if (n.owner === 'A') {
                    const prob = 0.0058 * (1 - space.kp/9) * (1 + space.bz/20);
                    if (Math.random() < prob) {
                        growFrom(i, 'A', 1.1 + (space.bz > 0 ? 0.6 : 0));
                    }
                }
            });

            nodes.forEach((n, i) => {
                if (n.owner === 'B') {
                    const windFactor = (space.wind - 300) / 400;
                    const bzFactor = space.bz < 0 ? Math.abs(space.bz)/12 : 0;
                    const prob = 0.018 * (0.6 + windFactor*1.1 + bzFactor*1.4);
                    if (Math.random() < prob) {
                        growFrom(i, 'B', 2.4 + windFactor*2.2 + bzFactor*2.8);
                    }
                }
            });

            const stormIntensity =
                (space.kp / 9) * 0.4 +
                (space.proton > 30 ? (space.proton-20)/200 : 0) +
                (space.flare !== 'None' ? 0.35 : 0) +
                (space.bz < -8 ? 0.45 : 0);

            if (stormIntensity > 0.15) {
                nodes.forEach(n => {
                    if (n.owner) {
                        if (Math.random() < 0.008 + stormIntensity * 0.09) {
                            if (Math.random() < 0.45) n.owner = null;
                            n.strength *= 0.88;
                            n.corruption = Math.min(1, n.corruption + 0.12 + stormIntensity*0.3);
                        }
                    }
                });
            }

            if (stormIntensity < 0.1) {
                nodes.forEach(n => {
                    if (n.corruption > 0) n.corruption -= 0.003;
                });
            }
        }

        function growFrom(idx, civ, maxJump) {
            const origin = nodes[idx];
            const candidates = [];
            nodes.forEach((t, j) => {
                if (t.owner) return;
                const d = Math.hypot(t.x - origin.x, t.y - origin.y);
                if (d < MAX_DIST * maxJump) {
                    candidates.push({i: j, d});
                }
            });
            if (!candidates.length) return;
            if (civ === 'B') {
                candidates.sort((a,b) => a.d - b.d + (Math.random()-0.5)*140);
            } else {
                candidates.sort((a,b) => a.d - b.d);
            }
            nodes[candidates[0].i].owner = civ;
        }

        function drawGrain() {
            ctx.globalAlpha = 0.05;
            ctx.fillStyle = '#0a0a12';
            const grainSize = 1.9;
            for (let i = 0; i < w * h / 11000; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const s = Math.random() * grainSize;
                ctx.fillRect(x, y, s, s);
            }
            ctx.globalAlpha = 1;
        }

        function drawNebula() {
            const t = Date.now() * 0.00006;
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.022;
            const layers = [
                { cx: w*0.33 + Math.sin(t*0.9)*90, cy: h*0.38 + Math.cos(t*1.1)*70, rIn:220, rOut:880, c1:'#18002e', c2:'rgba(40,0,90,0.11)' },
                { cx: w*0.68 + Math.cos(t*1.05)*120, cy: h*0.59 + Math.sin(t*1.25)*95, rIn:280, rOut:1100, c1:'#0f0022', c2:'rgba(30,0,80,0.09)' },
                { cx: w*0.18 + Math.sin(t*0.8+4)*70, cy: h*0.72 + Math.cos(t*0.9+3)*80, rIn:180, rOut:720, c1:'#080014', c2:'rgba(20,0,60,0.07)' }
            ];
            layers.forEach(l => {
                let grd = ctx.createRadialGradient(l.cx, l.cy, l.rIn, l.cx, l.cy, l.rOut);
                grd.addColorStop(0, l.c1);
                grd.addColorStop(0.48, l.c2);
                grd.addColorStop(1, 'transparent');
                ctx.fillStyle = grd;
                ctx.fillRect(0,0,w,h);
            });
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
        }

        function draw() {
            ctx.fillStyle = 'rgba(0,0,4,0.14)';
            ctx.fillRect(0,0,w,h);
            drawNebula();
            drawGrain();

            const time = Date.now() * 0.00042;   // –ø–æ–≤—ñ–ª—å–Ω—ñ—à–µ

            ctx.lineCap = 'round';
            edges.forEach(e => {
                const n1 = nodes[e.a];
                const n2 = nodes[e.b];
                if (!n1.owner && !n2.owner) return;

                let alphaMult = (n1.strength + n2.strength) / 2 * (1 - (n1.corruption + n2.corruption)/2);

                let col;
                if (n1.owner === n2.owner && n1.owner) {
                    col = n1.owner === 'A'
                        ? `hsla(248, 90%, 72%, ${e.baseAlpha * (0.42 + n1.breath*0.58) * alphaMult})`   // indigo-violet
                        : `hsla(330, 92%, 64%, ${e.baseAlpha * (0.42 + n1.breath*0.58) * alphaMult})`; // deep magenta-red
                } else {
                    const hue = (time*0.3 + (n1.phase + n2.phase) * 0.4) * 40 + 240;
                    col = `hsla(${hue % 360}, 70%, 58%, ${0.12 * alphaMult})`;
                }

                const wave = Math.sin(time*1.6 + (n1.x+n2.x)*0.007) * 0.5 + 0.5;
                const alpha = e.baseAlpha * (0.62 + wave*0.38) * alphaMult;

                ctx.globalAlpha = alpha;
                ctx.strokeStyle = col;
                ctx.lineWidth = 0.8 + (n1.breath + n2.breath) * 1.7;   // —Ç—Ä–æ—Ö–∏ —Ç–æ–Ω—à—ñ –ª—ñ–Ω—ñ—ó

                const mx = (n1.x + n2.x)/2 + Math.sin(time*2.8 + n1.phase*1.1)*4;   // –º–µ–Ω—à —Ö–∞–æ—Ç–∏—á–Ω–æ
                const my = (n1.y + n2.y)/2 + Math.cos(time*3.1 + n2.phase*1.2)*4;

                ctx.beginPath();
                ctx.moveTo(n1.x, n1.y);
                ctx.quadraticCurveTo(mx, my, n2.x, n2.y);
                ctx.stroke();
            });
            ctx.globalAlpha = 1;

            nodes.forEach(n => {
                if (!n.owner) return;

                const pulse = Math.sin(n.phase + Date.now()*0.0009) * 1.2 + 1.8;   // –º‚Äô—è–∫—à–∞ –ø—É–ª—å—Å–∞—Ü—ñ—è
                const baseGlow = n.owner === 'A' ? 'rgba(160,140,255,0.68)' : 'rgba(255,90,190,0.74)';
                const fillCol = n.owner === 'A' ? '#c4b8ff' : '#ff9edc';
                const corruptionFade = 1 - n.corruption * 0.78;

                ctx.shadowBlur = 18 + pulse * 6;
                ctx.shadowColor = baseGlow;
                ctx.fillStyle = fillCol;
                ctx.globalAlpha = corruptionFade * 0.90;
                ctx.beginPath();
                ctx.arc(n.x, n.y, pulse * 0.92, 0, Math.PI*2);
                ctx.fill();

                ctx.shadowBlur = 28;
                ctx.fillStyle = n.owner === 'A' ? 'rgba(160,140,255,0.14)' : 'rgba(255,90,190,0.17)';
                ctx.beginPath();
                ctx.arc(n.x, n.y, pulse * 2.2, 0, Math.PI*2);
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            });

            let ca = 0, cb = 0;
            nodes.forEach(n => {
                if (n.owner === 'A') ca++;
                if (n.owner === 'B') cb++;
            });
            const total = ca + cb || 1;
            document.getElementById('pct-a').textContent = (ca / total * 100).toFixed(1) + '%';
            document.getElementById('pct-b').textContent = (cb / total * 100).toFixed(1) + '%';

            const activeEdges = edges.filter(e => nodes[e.a].owner || nodes[e.b].owner).length;
            document.getElementById('edges').textContent = activeEdges;
        }

        function loop() {
            simulate();
            draw();
            requestAnimationFrame(loop);
        }

        setInterval(updateSpace, 60000);
        updateSpace().catch(console.warn);
        loop();
    </script>
</body>
</html>
