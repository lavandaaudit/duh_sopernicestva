<!DOCTYPE html>
<html lang="uk">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IBONARIUM ‚Äî Deep Ethereal</title>
    <style>
        body {
            margin: 0;
            background: radial-gradient(circle at center, #0b001a 0%, #000000 100%);
            color: #e0d8ff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
            mix-blend-mode: screen;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            font-size: 0.85em;
            line-height: 1.5;
            text-shadow: 0 0 10px #2a0044, 0 0 20px #550088;
            letter-spacing: 0.5px;
            opacity: 0.95;
            user-select: none;
            z-index: 10;
            max-width: 260px;
        }

        #ui h1 {
            margin: 0 0 10px 0;
            font-size: 1.4em;
            background: linear-gradient(90deg, #8fe0ff, #cba6ff, #ff94d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 2px;
            font-weight: 300;
        }

        .civ-a {
            color: #80dfff;
            text-shadow: 0 0 12px #00aaff;
            font-weight: bold;
        }

        .civ-b {
            color: #ff80b3;
            text-shadow: 0 0 12px #ff0066;
            font-weight: bold;
        }

        .stats,
        .space-info,
        .legend {
            margin-top: 8px;
            background: rgba(5, 2, 12, 0.6);
            /* Darker panel */
            padding: 10px;
            border-radius: 8px;
            border-left: 2px solid rgba(100, 100, 255, 0.15);
            backdrop-filter: blur(4px);
        }

        .label {
            opacity: 0.6;
            font-size: 0.9em;
            display: inline-block;
            min-width: 100px;
        }

        .val {
            font-family: monospace;
            font-size: 1.1em;
            color: #fff;
            opacity: 0.9;
        }

        .timer {
            font-family: monospace;
            color: #b0a0ff;
            font-size: 0.9em;
            margin-top: 5px;
            display: block;
        }

        .legend h3 {
            margin: 0 0 5px 0;
            font-size: 0.95em;
            color: #fff;
            opacity: 0.8;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 2px;
        }

        .legend-item {
            font-size: 0.8em;
            margin-bottom: 3px;
            color: #aaa;
        }

        .legend-key {
            color: #8fe0ff;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <div id="ui">
        <h1>üåå IBONARIUM <span style="font-size:0.6em; opacity:0.6;">DEEP</span></h1>

        <div class="space-info">
            <div><span class="label">Kp Index:</span> <span id="kp" class="val">--</span></div>
            <div><span class="label">Solar Wind:</span> <span id="wind" class="val">--</span> km/s</div>
            <div><span class="label">Protons:</span> <span id="proton" class="val">--</span></div>
            <div><span class="label">Bz Field:</span> <span id="bz" class="val">--</span> nT</div>
            <div><span class="label">Flares:</span> <span id="flare" class="val">None</span></div>
        </div>

        <div class="stats">
            <span class="civ-a">Order</span> <span id="pct-a">0.0%</span> &nbsp;|&nbsp;
            <span class="civ-b">Flux</span> <span id="pct-b">0.0%</span><br>
            <div style="margin-top:4px; font-size:0.9em; opacity:0.8;">
                –ó–≤‚Äô—è–∑–∫—ñ–≤: <span id="edges">0</span>
            </div>
            <div class="timer" id="timer">00:00:00</div>
        </div>

        <div class="legend">
            <h3>–°–ò–°–¢–ï–ú–ù–ò–ô –ü–†–û–¢–û–ö–û–õ</h3>
            <div class="legend-item"><span class="legend-key">Kp Index:</span> –•–∞–æ—Å —Ç–∞ —Ç—Ä–µ–º—Ç—ñ–Ω–Ω—è –≤—É–∑–ª—ñ–≤.</div>
            <div class="legend-item"><span class="legend-key">Solar Wind:</span> –®–≤–∏–¥–∫—ñ—Å—Ç—å –¥—Ä–µ–π—Ñ—É –º–∞—Ç–µ—Ä—ñ—ó.</div>
            <div class="legend-item"><span class="legend-key">Bz Field:</span> –ö–æ–ª—ñ—Ä —Ç—É–º–∞–Ω–Ω–æ—Å—Ç—ñ (+/-).</div>
            <div class="legend-item"><span class="legend-key">Flares:</span> –Ü–Ω—Ç–µ–Ω—Å–∏–≤–Ω—ñ—Å—Ç—å –ø—É–ª—å—Å–∞—Ü—ñ—ó.</div>
            <div class="legend-item"><span class="legend-key">Electrons:</span> –Ü—Å–∫—Ä–∏ –Ω–∞ –ª—ñ–Ω—ñ—è—Ö.</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        let w, h;
        function resize() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- TIMING ---
        const startT = new Date();
        startT.setHours(0, 0, 0, 0);
        setInterval(() => {
            const s = Math.floor((new Date() - startT) / 1000);
            const d = Math.floor(s / 86400);
            const hh = Math.floor((s % 86400) / 3600).toString().padStart(2, '0');
            const mm = Math.floor((s % 3600) / 60).toString().padStart(2, '0');
            const ss = (s % 60).toString().padStart(2, '0');
            document.getElementById('timer').textContent = `${d}–¥ ${hh}:${mm}:${ss}`;
        }, 1000);

        // --- CONFIG ---
        const NODES = 580;
        const MAX_DIST = 190;
        const nodes = [];

        class Node {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.15;
                this.vy = (Math.random() - 0.5) * 0.15;
                this.owner = null;
                this.phase = Math.random() * Math.PI * 2;
                this.breath = 0;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                const pad = 60;
                if (this.x < -pad) this.x = w + pad;
                if (this.x > w + pad) this.x = -pad;
                if (this.y < -pad) this.y = h + pad;
                if (this.y > h + pad) this.y = -pad;
            }
        }

        for (let i = 0; i < NODES; i++) {
            let x = Math.random() * w * 1.2 - w * 0.1;
            let y = Math.random() * h * 1.2 - h * 0.1;
            nodes.push(new Node(x, y));
        }

        const centerA = { x: w * 0.28, y: h * 0.54 };
        const centerB = { x: w * 0.72, y: h * 0.46 };
        nodes.forEach(n => {
            if (Math.hypot(n.x - centerA.x, n.y - centerA.y) < 100) n.owner = 'A';
            if (Math.hypot(n.x - centerB.x, n.y - centerB.y) < 100) n.owner = 'B';
        });

        // --- API DATA ---
        let space = {
            kp: 2.3, flare: 'None', proton: 5, wind: 380, bz: 1.2, electrons: 500
        };

        async function updateSpace() {
            try {
                const f = async (u) => { try { const r = await fetch(u); return await r.json(); } catch { return null; } };

                const [kp, fl, pro, pla, mag, elec] = await Promise.all([
                    f('https://services.swpc.noaa.gov/products/noaa-planetary-k-index.json'),
                    f('https://services.swpc.noaa.gov/json/goes/primary/xray-flares-latest.json'),
                    f('https://services.swpc.noaa.gov/json/goes/primary/integral-protons-1-day.json'),
                    f('https://services.swpc.noaa.gov/products/solar-wind/plasma-1-minute.json'),
                    f('https://services.swpc.noaa.gov/products/solar-wind/mag-1-minute.json'),
                    f('https://services.swpc.noaa.gov/json/goes/primary/integral-electrons-1-day.json')
                ]);

                if (kp && kp.length) space.kp = parseFloat(kp[kp.length - 1][1]) || 2;
                if (fl && fl.length) space.flare = fl[fl.length - 1].current_class || 'A';
                if (pro) {
                    const p = pro.find(x => x.energy === '>=10 MeV');
                    if (p) space.proton = parseFloat(p.flux);
                }
                if (pla && pla.length) space.wind = parseFloat(pla[pla.length - 1][2]) || 380;
                if (mag && mag.length) space.bz = parseFloat(mag[mag.length - 1][3]) || 0;
                if (elec && elec.length) space.electrons = parseFloat(elec[elec.length - 1].flux);

                document.getElementById('kp').textContent = space.kp.toFixed(1);
                document.getElementById('wind').textContent = Math.round(space.wind);
                document.getElementById('flare').textContent = space.flare;
                document.getElementById('proton').textContent = space.proton.toFixed(1);
                document.getElementById('bz').textContent = space.bz.toFixed(1);
            } catch (e) { console.warn('API fetch fail', e); }
        }

        // --- LOGIC ---
        function simulate() {
            const now = Date.now();
            const driftX = (space.wind - 300) * 0.00002;

            nodes.forEach(n => {
                n.vx += driftX * 0.1;
                n.vx += (Math.random() - 0.5) * space.kp * 0.001;
                n.vy += (Math.random() - 0.5) * space.kp * 0.001;
                n.vx = Math.max(-0.5, Math.min(0.5, n.vx * 0.99));
                n.update();

                // Deep breathing cycle
                n.breath = Math.sin(now * 0.0012 + n.phase) * 0.5 + 0.5;
            });

            // Growth
            nodes.forEach((n, i) => {
                let biasA = space.bz > 0 ? 1.2 : 0.8;
                let biasB = space.bz < 0 ? 1.2 : 0.8;
                if (n.owner === 'A' && Math.random() < 0.005 * biasA) growFrom(i, 'A', 1.1);
                if (n.owner === 'B' && Math.random() < 0.005 * biasB) growFrom(i, 'B', 1.3);
            });
        }

        function growFrom(idx, civ, rangeMod) {
            const origin = nodes[idx];
            let bestT = -1, bestD = 9999;
            for (let k = 0; k < 20; k++) {
                const rid = Math.floor(Math.random() * NODES);
                const t = nodes[rid];
                if (t.owner) continue;
                const d = Math.hypot(t.x - origin.x, t.y - origin.y);
                if (d < MAX_DIST * rangeMod && d < bestD) {
                    bestD = d; bestT = rid;
                }
            }
            if (bestT !== -1) nodes[bestT].owner = civ;
        }

        // --- RENDER ---
        function drawNebula() {
            const t = Date.now() * 0.0002;
            ctx.globalCompositeOperation = 'screen';
            // Darker, subtler nebula for depth
            const bzShift = space.bz * 3;
            const clouds = [
                { x: w * 0.3 + Math.sin(t) * 50, y: h * 0.4, r: 600, c: [15, 0, 40 + bzShift] },
                { x: w * 0.7 + Math.cos(t) * 60, y: h * 0.6, r: 700, c: [5 - bzShift, 0, 30] }
            ];
            clouds.forEach(c => {
                const g = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, c.r);
                g.addColorStop(0, `rgba(${c.c[0]}, ${c.c[1]}, ${c.c[2]}, 0.15)`);
                g.addColorStop(1, 'transparent');
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, w, h);
            });
            ctx.globalCompositeOperation = 'source-over';
        }

        function draw() {
            // Dark background clearing for trails
            ctx.fillStyle = 'rgba(0, 0, 5, 0.2)';
            ctx.fillRect(0, 0, w, h);
            drawNebula();

            const time = Date.now();
            let edgeCount = 0;
            let ca = 0, cb = 0;

            const active = nodes.filter(n => n.owner);
            active.forEach(n => { if (n.owner === 'A') ca++; else cb++; });

            const limit = Math.min(active.length, 380);
            const sparkChance = space.electrons / 200000;

            ctx.lineCap = 'round';
            for (let i = 0; i < limit; i++) {
                const n1 = active[i];
                for (let j = i + 1; j < limit; j++) {
                    const n2 = active[j];
                    const dx = n1.x - n2.x; const dy = n1.y - n2.y;
                    if (Math.abs(dx) > MAX_DIST || Math.abs(dy) > MAX_DIST) continue;

                    const d = Math.hypot(dx, dy);
                    if (d < MAX_DIST) {
                        // Squared falloff for DEPTH (faint far lines)
                        const normD = d / MAX_DIST;
                        const alpha = (1 - normD) * (1 - normD);

                        if (Math.random() < sparkChance) {
                            ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
                            ctx.lineWidth = 1.5;
                        } else if (n1.owner === n2.owner) {
                            const isA = n1.owner === 'A';
                            // Iridescence: Time + Position based hue shift
                            const baseHue = isA ? 190 : 320;
                            const irid = Math.sin(time * 0.002 + (n1.x + n1.y) * 0.005) * 20;

                            // Breath sync
                            const breathMix = (n1.breath + n2.breath) * 0.5;

                            // Muted opacity (0.25) so nodes pop
                            const op = alpha * 0.25 * (0.6 + breathMix * 0.4);
                            const width = 0.5 + breathMix * 1.5; // Pulse width

                            ctx.strokeStyle = `hsla(${baseHue + irid}, 80%, 65%, ${op})`;
                            ctx.lineWidth = width;
                        } else {
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.05})`;
                            ctx.lineWidth = 0.5;
                        }

                        // Curved flow
                        const midX = (n1.x + n2.x) / 2 + Math.sin(time * 0.0015 + d * 0.02) * 8;
                        const midY = (n1.y + n2.y) / 2 + Math.cos(time * 0.0015 + d * 0.02) * 8;
                        ctx.beginPath(); ctx.moveTo(n1.x, n1.y); ctx.quadraticCurveTo(midX, midY, n2.x, n2.y); ctx.stroke();
                        edgeCount++;
                    }
                }
            }

            // NODES - Enhanced Glow
            active.forEach(n => {
                const isA = n.owner === 'A';
                const baseCol = isA ? '#50c0ff' : '#ff5090'; // More vivid core

                // Breath calculation
                const b = n.breath;

                // Flare boost
                let boost = 1;
                if (space.flare.startsWith('M')) boost = 1.5;

                ctx.globalCompositeOperation = 'screen';

                // Outer diffuse glow (Deep)
                ctx.shadowBlur = 30 * boost;
                ctx.shadowColor = baseCol;
                ctx.fillStyle = baseCol;
                ctx.globalAlpha = 0.3 * b;
                ctx.beginPath(); ctx.arc(n.x, n.y, (4 + b * 6) * boost, 0, 6.28); ctx.fill();

                // Inner bright core
                ctx.shadowBlur = 10 * boost;
                ctx.globalAlpha = 0.8 + b * 0.2;
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(n.x, n.y, 1.5 * boost, 0, 6.28); ctx.fill();

                ctx.shadowBlur = 0;
                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = 1;
            });

            document.getElementById('edges').textContent = edgeCount > 5000 ? '>5000' : edgeCount;
            const tot = ca + cb || 1;
            document.getElementById('pct-a').textContent = (ca / NODES * 100).toFixed(1) + '%';
            document.getElementById('pct-b').textContent = (cb / NODES * 100).toFixed(1) + '%';
        }

        function loop() {
            simulate();
            draw();
            requestAnimationFrame(loop);
        }

        updateSpace();
        setInterval(updateSpace, 60000);
        loop();

    </script>
</body>

</html>
