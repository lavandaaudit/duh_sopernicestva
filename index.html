<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IBONARIUM ‚Äî –ñ–∏–≤–∞ –ü–∞–≤—É—Ç–∏–Ω–∞</title>
    <style>
        body {
            margin: 0;
            background: radial-gradient(ellipse at center, #0a0015 0%, #000 70%);
            color: #e0d8ff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            mix-blend-mode: screen;
        }
        #ui {
            position: absolute;
            top: 14px;
            left: 16px;
            pointer-events: none;
            font-size: 0.82em;
            line-height: 1.38;
            text-shadow: 0 0 9px #200040, 0 0 18px #400080;
            letter-spacing: 0.3px;
            opacity: 0.92;
            user-select: none;
        }
        #ui h1 {
            margin: 0 0 6px 0;
            font-size: 1.24em;
            background: linear-gradient(90deg, #c4a8ff, #ff8ad8, #ff6ac2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 1px;
        }
        .civ-a { color: #b399ff; text-shadow: 0 0 10px #b399ff; }
        .civ-b { color: #ff7ac8; text-shadow: 0 0 10px #ff7ac8; }
        .stats, .space-info {
            margin-top: 4px;
            opacity: 0.9;
        }
        .space-info div, .stats div {
            margin: 2px 0;
        }
        .label {
            opacity: 0.75;
            font-size: 0.92em;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <div id="ui">
        <h1>üåå IBONARIUM</h1>
        
        <div class="space-info">
            <div><span class="label">Kp:</span> <span id="kp">2.3</span></div>
            <div><span class="label">Flares:</span> <span id="flare">None</span></div>
            <div><span class="label">Protons ‚â•10 MeV:</span> <span id="proton">low</span></div>
            <div><span class="label">Solar Wind:</span> <span id="wind">380</span> km/s</div>
            <div><span class="label">Bz:</span> <span id="bz">+1.2</span> nT</div>
            <div><span class="label">Dst:</span> <span id="dst">-18</span> nT</div>
        </div>

        <div class="stats">
            <span class="civ-a">Order</span> <span id="pct-a">0.0%</span> ‚ÄÉ|
            <span class="civ-b">Flux</span> <span id="pct-b">0.0%</span><br>
            –ê–∫—Ç–∏–≤–Ω–∏—Ö –∑–≤‚Äô—è–∑–∫—ñ–≤: <span id="edges">0</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        let w, h;

        function resize() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        const NODES = 520;
        const MAX_DIST = 168;
        const nodes = [];
        const edges = [];

        class Node {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.owner = null;
                this.strength = 1.0;
                this.phase = Math.random() * Math.PI * 2;
                this.breath = 0;
                this.corruption = 0;     // 0..1 ‚Äî —á–∏–º –≤–∏—â–µ, —Ç–∏–º —Å–ª–∞–±—à–µ —Å–≤—ñ—Ç–∏—Ç—å—Å—è
            }
        }

        // –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –≤—É–∑–ª—ñ–≤
        for (let i = 0; i < NODES; i++) {
            let x = Math.random() * w * 1.7 - w * 0.35;
            let y = Math.random() * h * 1.7 - h * 0.35;
            nodes.push(new Node(x, y));
        }

        // –°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ä–µ–±–µ—Ä
        for (let i = 0; i < NODES; i++) {
            for (let j = i + 1; j < NODES; j++) {
                const d = Math.hypot(nodes[i].x - nodes[j].x, nodes[i].y - nodes[j].y);
                if (d < MAX_DIST) {
                    edges.push({
                        a: i,
                        b: j,
                        baseAlpha: 0.08 + (1 - d / MAX_DIST) * 0.42,
                        length: d
                    });
                }
            }
        }

        // –ü–æ—á–∞—Ç–∫–æ–≤—ñ —Ü–µ–Ω—Ç—Ä–∏ —Ü–∏–≤—ñ–ª—ñ–∑–∞—Ü—ñ–π
        const centerA = { x: w * 0.28, y: h * 0.54 };
        const centerB = { x: w * 0.72, y: h * 0.46 };

        let startA = 0, distA = Infinity;
        let startB = 0, distB = Infinity;

        nodes.forEach((n, i) => {
            const da = Math.hypot(n.x - centerA.x, n.y - centerA.y);
            const db = Math.hypot(n.x - centerB.x, n.y - centerB.y);
            if (da < distA) { distA = da; startA = i; }
            if (db < distB) { distB = db; startB = i; }
        });

        nodes[startA].owner = 'A';
        nodes[startB].owner = 'B';

        // –†–µ–∞–ª—å–Ω—ñ –∫–æ—Å–º—ñ—á–Ω—ñ –¥–∞–Ω—ñ
        let space = {
            kp: 2.3,
            flare: 'None',
            proton: 8,
            wind: 380,
            bz: 1.2,
            dst: -18
        };

        // –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Ä–µ–∞–ª—å–Ω–∏—Ö –¥–∞–Ω–∏—Ö –∑ NOAA
        async function updateSpace() {
            try {
                // Kp
                const kpRes = await fetch('https://services.swpc.noaa.gov/products/noaa-planetary-k-index.json');
                const kpData = await kpRes.json();
                space.kp = parseFloat(kpData[kpData.length-1][1]) || space.kp;

                // X-ray flares (–æ—Å—Ç–∞–Ω–Ω—è –∑–Ω–∞—á—É—â–∞)
                const flareRes = await fetch('https://services.swpc.noaa.gov/json/goes/primary/xray-flares-latest.json');
                const flares = await flareRes.json();
                const last = flares[flares.length-1] || {};
                const cls = last.current_class || last.max_class || 'None';
                space.flare = (cls.startsWith('M') || cls.startsWith('X')) ? cls[0] : 'None';

                // Protons >10 MeV
                const protonRes = await fetch('https://services.swpc.noaa.gov/json/goes/primary/integral-protons-1-day.json');
                const protons = await protonRes.json();
                const p = protons.filter(p => p.energy === '>=10 MeV').pop();
                space.proton = p ? p.flux : space.proton;

                // Solar wind + Bz
                const windRes = await fetch('https://services.swpc.noaa.gov/products/solar-wind/plasma-1-minute.json');
                const wind = await windRes.json();
                const lastWind = wind[wind.length-1] || {};
                space.wind = parseFloat(lastWind[2]) || space.wind;
                space.bz   = parseFloat(lastWind[3]) || space.bz;

                // Dst (–ø—Ä–∏–±–ª–∏–∑–Ω–æ, –∑ —ñ–Ω—à–∏—Ö –¥–∂–µ—Ä–µ–ª –∞–±–æ —Ñ—ñ–∫—Ç–∏–≤–Ω–æ –ø–æ–∫–∏ —â–æ)
                // –†–µ–∞–ª—å–Ω–∏–π Dst –º–æ–∂–Ω–∞ –±—Ä–∞—Ç–∏ –∑ Kyoto, –∞–ª–µ —Ç—É—Ç —Å–ø—Ä–æ—â–µ–Ω–æ
                space.dst = space.kp > 5 ? -50 - space.kp*12 : -10 - space.kp*4;

                // –û–Ω–æ–≤–ª–µ–Ω–Ω—è —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É
                document.getElementById('kp').textContent     = space.kp.toFixed(1);
                document.getElementById('flare').textContent  = space.flare;
                document.getElementById('proton').textContent = space.proton > 100 ? 'extreme' : space.proton > 30 ? 'high' : space.proton > 10 ? 'elevated' : 'low';
                document.getElementById('wind').textContent   = Math.round(space.wind);
                document.getElementById('bz').textContent     = space.bz.toFixed(1);
                document.getElementById('dst').textContent    = Math.round(space.dst);
            } catch(e) {
                console.warn("Space weather fetch error", e);
            }
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        //          –°–∏–º—É–ª—è—Ü—ñ—è –∑ —Å–∏–ª—å–Ω—ñ—à–∏–º –≤–ø–ª–∏–≤–æ–º –¥–∞–Ω–∏—Ö
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        function simulate() {
            const now = Date.now();
            nodes.forEach(n => {
                n.breath = Math.sin(now * 0.00042 + n.phase) * 0.5 + 0.5;
            });

            // Order (A) ‚Äî —Å—Ç–∞–±—ñ–ª—å–Ω–∞, –ø–æ–≤—ñ–ª—å–Ω–∞ –µ–∫—Å–ø–∞–Ω—Å—ñ—è, –ø—Ä–∏–≥–Ω—ñ—á—É—î—Ç—å—Å—è –≤–∏—Å–æ–∫–∏–º Kp
            nodes.forEach((n, i) => {
                if (n.owner === 'A') {
                    const prob = 0.0058 * (1 - space.kp/9) * (1 + space.bz/20);
                    if (Math.random() < prob) {
                        growFrom(i, 'A', 1.1 + (space.bz > 0 ? 0.6 : 0));
                    }
                }
            });

            // Flux (B) ‚Äî —à–≤–∏–¥–∫–∞, —Ö–∞–æ—Ç–∏—á–Ω–∞ –µ–∫—Å–ø–∞–Ω—Å—ñ—è, –ø—ñ–¥—Å–∏–ª—é—î—Ç—å—Å—è —à–≤–∏–¥–∫–∏–º –≤—ñ—Ç—Ä–æ–º —Ç–∞ –Ω–µ–≥–∞—Ç–∏–≤–Ω–∏–º Bz
            nodes.forEach((n, i) => {
                if (n.owner === 'B') {
                    const windFactor = (space.wind - 300) / 400;
                    const bzFactor   = space.bz < 0 ? Math.abs(space.bz)/12 : 0;
                    const prob = 0.018 * (0.6 + windFactor*1.1 + bzFactor*1.4);
                    if (Math.random() < prob) {
                        growFrom(i, 'B', 2.4 + windFactor*2.2 + bzFactor*2.8);
                    }
                }
            });

            // –°–æ–Ω—è—á–Ω—ñ –±—É—Ä—ñ ‚Üí –ø–æ—à–∫–æ–¥–∂–µ–Ω–Ω—è —Ç–∞ –∫–æ—Ä—É–ø—Ü—ñ—è
            const stormIntensity = 
                (space.kp / 9) * 0.4 +
                (space.proton > 30 ? (space.proton-20)/200 : 0) +
                (space.flare !== 'None' ? 0.35 : 0) +
                (space.bz < -8 ? 0.45 : 0);

            if (stormIntensity > 0.15) {
                nodes.forEach(n => {
                    if (n.owner) {
                        if (Math.random() < 0.008 + stormIntensity * 0.09) {
                            if (Math.random() < 0.45) n.owner = null;
                            n.strength *= 0.88;
                            n.corruption = Math.min(1, n.corruption + 0.12 + stormIntensity*0.3);
                        }
                    }
                });
            }

            // –ü–æ–≤—ñ–ª—å–Ω–µ –æ—á–∏—â–µ–Ω–Ω—è –∫–æ—Ä—É–ø—Ü—ñ—ó –∫–æ–ª–∏ —Ç–∏—Ö–æ
            if (stormIntensity < 0.1) {
                nodes.forEach(n => {
                    if (n.corruption > 0) n.corruption -= 0.003;
                });
            }
        }

        function growFrom(idx, civ, maxJump) {
            const origin = nodes[idx];
            const candidates = [];

            nodes.forEach((t, j) => {
                if (t.owner) return;
                const d = Math.hypot(t.x - origin.x, t.y - origin.y);
                if (d < MAX_DIST * maxJump) {
                    candidates.push({i: j, d});
                }
            });

            if (!candidates.length) return;

            // B —Å–æ—Ä—Ç—É—î –∑ –Ω–µ–≤–µ–ª–∏–∫–∏–º —à—É–º–æ–º (–±—ñ–ª—å—à —Ö–∞–æ—Ç–∏—á–Ω–æ)
            if (civ === 'B') {
                candidates.sort((a,b) => a.d - b.d + (Math.random()-0.5)*140);
            } else {
                candidates.sort((a,b) => a.d - b.d);
            }

            nodes[candidates[0].i].owner = civ;
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        //                  –ú–∞–ª—é–≤–∞–Ω–Ω—è
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        function drawNebula() {
            const t = Date.now() * 0.00008;
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.048;

            const layers = [
                { cx: w*0.36 + Math.sin(t*1.2)*110, cy: h*0.34 + Math.cos(t*0.95)*85, rIn:230, rOut:920, c1:'#3f005c', c2:'rgba(70,20,110,0.22)' },
                { cx: w*0.66 + Math.cos(t*0.85)*140, cy: h*0.56 + Math.sin(t*1.4)*110, rIn:300, rOut:1180, c1:'#22003b', c2:'rgba(50,0,90,0.19)' },
                { cx: w*0.14 + Math.sin(t*0.7+3)*80,  cy: h*0.76 + Math.cos(t*0.75+2)*90, rIn:200, rOut:780, c1:'#140028', c2:'rgba(35,0,75,0.16)' }
            ];

            layers.forEach(l => {
                let grd = ctx.createRadialGradient(l.cx, l.cy, l.rIn, l.cx, l.cy, l.rOut);
                grd.addColorStop(0,   l.c1);
                grd.addColorStop(0.42,l.c2);
                grd.addColorStop(1,   'transparent');
                ctx.fillStyle = grd;
                ctx.fillRect(0,0,w,h);
            });

            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
        }

        function draw() {
            ctx.fillStyle = 'rgba(0,0,10,0.13)';
            ctx.fillRect(0,0,w,h);

            drawNebula();

            const time = Date.now() * 0.00065;

            ctx.lineCap = 'round';

            edges.forEach(e => {
                const n1 = nodes[e.a];
                const n2 = nodes[e.b];
                if (!n1.owner && !n2.owner) return;

                let alphaMult = (n1.strength + n2.strength) / 2 * (1 - (n1.corruption + n2.corruption)/2);

                let col;
                if (n1.owner === n2.owner && n1.owner) {
                    col = n1.owner === 'A'
                        ? `hsla(262, 85%, 74%, ${e.baseAlpha * (0.38 + n1.breath*0.62) * alphaMult})`
                        : `hsla(322, 90%, 68%, ${e.baseAlpha * (0.38 + n1.breath*0.62) * alphaMult})`;
                } else {
                    const hue = (time*0.4 + n1.phase + n2.phase) * 50 + 275;
                    col = `hsla(${hue % 360}, 75%, 62%, ${0.14 * alphaMult})`;
                }

                const wave = Math.sin(time*2.4 + (n1.x+n2.x)*0.009) * 0.5 + 0.5;
                const alpha = e.baseAlpha * (0.55 + wave*0.45) * alphaMult;

                ctx.globalAlpha = alpha;
                ctx.strokeStyle = col;
                ctx.lineWidth = 0.7 + (n1.breath + n2.breath) * 2.1;

                const mx = (n1.x + n2.x)/2 + Math.sin(time*3.8 + n1.phase*1.3)*6;
                const my = (n1.y + n2.y)/2 + Math.cos(time*4.1 + n2.phase*1.4)*6;

                ctx.beginPath();
                ctx.moveTo(n1.x, n1.y);
                ctx.quadraticCurveTo(mx, my, n2.x, n2.y);
                ctx.stroke();
            });

            ctx.globalAlpha = 1;

            // –í—É–∑–ª–∏
            nodes.forEach(n => {
                if (!n.owner) return;

                const pulse = Math.sin(n.phase + Date.now()*0.0013) * 1.5 + 2.0;
                const baseGlow = n.owner === 'A' ? 'rgba(190,150,255,0.72)' : 'rgba(255,120,210,0.78)';
                const fillCol   = n.owner === 'A' ? '#d8ccff' : '#ffc0ea';

                const corruptionFade = 1 - n.corruption * 0.75;

                ctx.shadowBlur = 22 + pulse * 7;
                ctx.shadowColor = baseGlow;
                ctx.fillStyle = fillCol;
                ctx.globalAlpha = corruptionFade * 0.92;
                ctx.beginPath();
                ctx.arc(n.x, n.y, pulse * 0.95, 0, Math.PI*2);
                ctx.fill();

                ctx.shadowBlur = 32;
                ctx.fillStyle = n.owner === 'A' ? 'rgba(190,150,255,0.16)' : 'rgba(255,120,210,0.19)';
                ctx.beginPath();
                ctx.arc(n.x, n.y, pulse * 2.4, 0, Math.PI*2);
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            });

            // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
            let ca = 0, cb = 0;
            nodes.forEach(n => {
                if (n.owner === 'A') ca++;
                if (n.owner === 'B') cb++;
            });
            const total = ca + cb || 1;
            document.getElementById('pct-a').textContent = (ca / total * 100).toFixed(1) + '%';
            document.getElementById('pct-b').textContent = (cb / total * 100).toFixed(1) + '%';

            const activeEdges = edges.filter(e => nodes[e.a].owner || nodes[e.b].owner).length;
            document.getElementById('edges').textContent = activeEdges;
        }

        function loop() {
            simulate();
            draw();
            requestAnimationFrame(loop);
        }

        // –ó–∞–ø—É—Å–∫
        setInterval(updateSpace, 90000); // –∫–æ–∂–Ω—ñ 1.5 —Ö–≤
        updateSpace().catch(console.warn);
        loop();
    </script>
</body>
</html>
